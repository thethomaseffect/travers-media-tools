{"name":"Travers Media Tools","tagline":"A avconv-based media transcoder for the cloud that scales horizontally.","body":"Travers Media Encoder\r\n=====================\r\n\r\nOutline\r\n-------\r\n\r\nTravers Media Encoder is a cloud-based video and audio encoder that allows a user to convert media from one format to another over the web, with the actual transcoding being done on a server and then letting them download the result. Thanks to filepicker.io, the user can upload files from their own cloud storage service such as Dropbox without having the file locally. It is written in Python and uses the Django framework, libav encoding tools, SQLite and runs on linux.\r\n\r\n* [Video Demonstration](http://www.youtube.com/watch?v=UMhja2z2y34)\r\n* [Source Code](https://github.com/thethomaseffect/travers-media-tools)\r\n\r\nDemo Video\r\n----------\r\n\r\nIn the video, the application is running locally on port 8000. The integration with filepicker.io is demonstrated by using a dropbox file not on the local machine. When the user hits the \"Upload and Transcode\" button, the file is uploaded to the application server. Then, it is transcoded and when complete, the page will refresh with a download link to where the file is being statically served from. We can observe the differences between the input and output by using avprobe, a media information tool included with libav. Lastly, we view the video and confirm it indeed works.\r\n\r\n#### Input\r\n```\r\navprobe version 0.8.6-6:0.8.6-1ubuntu2, Copyright (c) 2007-2013 the Libav developers\r\n  built on Mar 30 2013 22:20:06 with gcc 4.7.2\r\nInput #0, mov,mp4,m4a,3gp,3g2,mj2, from 'input_small.mp4':\r\n  Metadata:\r\n    major_brand     : mp42\r\n    minor_version   : 0\r\n    compatible_brands: mp42isomavc1\r\n    creation_time   : 2010-03-20 21:29:11\r\n    encoder         : HandBrake 0.9.4 2009112300\r\n  Duration: 00:00:05.56, start: 0.000000, bitrate: 551 kb/s\r\n    Stream #0.0(und): Video: h264 (Constrained Baseline), yuv420p, 560x320, 465 kb/s, 30 fps, 30 tbr, 90k tbn, 60 tbc\r\n    Metadata:\r\n      creation_time   : 2010-03-20 21:29:11\r\n    Stream #0.1(eng): Audio: aac, 48000 Hz, mono, s16, 83 kb/s\r\n    Metadata:\r\n      creation_time   : 2010-03-20 21:29:11\r\n```\r\n\r\n#### Output\r\n```\r\navprobe version 0.8.6-6:0.8.6-1ubuntu2, Copyright (c) 2007-2013 the Libav developers\r\n  built on Mar 30 2013 22:20:06 with gcc 4.7.2\r\n[matroska,webm @ 0x1429b20] Estimating duration from bitrate, this may be inaccurate\r\nInput #0, matroska,webm, from 'input_small.mp4_transcoded.mkv':\r\n  Metadata:\r\n    MAJOR_BRAND     : mp42\r\n    MINOR_VERSION   : 0\r\n    COMPATIBLE_BRANDS: mp42isomavc1\r\n    CREATION_TIME   : 2010-03-20 21:29:11\r\n    ENCODER         : Lavf53.21.1\r\n  Duration: 00:00:05.56, start: 0.000000, bitrate: N/A\r\n    Stream #0.0(und): Video: mpeg4 (Simple Profile), yuv420p, 560x320 [PAR 1:1 DAR 7:4], 30 fps, 30 tbr, 1k tbn, 30 tbc (default)\r\n    Metadata:\r\n      CREATION_TIME   : 2010-03-20 21:29:11\r\n      LANGUAGE        : und\r\n    Stream #0.1(eng): Audio: vorbis, 48000 Hz, mono, s16 (default)\r\n    Metadata:\r\n      CREATION_TIME   : 2010-03-20 21:29:11\r\n      LANGUAGE        : eng\r\n```\r\n\r\nThe audio, video and container formats are all different in the output file, and as seen in the demo the output plays just as well as the input, but now uses completely free codecs.\r\n\r\n\r\nChallenges\r\n----------\r\n\r\nI decided to do this project mainly because I wanted to seriously challenge myself. For that reason, I decided to learn the Python programming language, the Django framework and the libav encoding tools. I have a keen interest in scalability so I planned for the application to horizontally scale with ease from the beginning. I researched many solutions for this and found celery combined with redis message queue to be the optimal solution.\r\n\r\nHowever, I quickly found that I didn't have the resources needed to confirm if the software could run on multiple machines, so I didn't actually implement distributed asynchronous messaging but kept it in mind so it would be easy to do if needed (in fact, it would only be about 5 lines of code).\r\n\r\nMy main challenge was the fact the encoding was much more difficult that I anticipated. The optimal settings used for each codec is equivalent to 2n^2, because the settings to encode from a => b are not the same as b => a. Note that this is an optimistic estimate since more seasoned encoders will want fine-grained control over each bitrate. Because of this, my demonstration is optimized for converting .mp4 files to .mkv as writing out endless settings files was not the reason I pursued this project.\r\n\r\nLearning a new programming language and then working inside a huge, mature framework written in it was no easy task. I started off learning with reading through the entire official python tutorial and most of the documentation related to collections, then watched all of Google Code's video lectures. I am always anxious to write idiomatic code so I read over the pep8 style guidelines many times to make sure my python code looked like python code.\r\n\r\nOne of the biggest problems I faced during development was parsing the console output of the avconv subprocess. The problem here is that python's build-in subprocess module sees a new line character as the signal to return that line to the program. However, once encoding starts avconv continuously write to the same line and the output cannot be read until encoding is finished. One of my goals was to include a progress bar during encoding and if I could not consume the current output this could not be done.\r\n\r\nAfter a lot of frustration and research I managed to achieve my goal using a third-party library called pexpect. pexpect is designed for controlling subprocesses rather than just executing them and it allowed me to parse the line of text that subprocess would not.\r\n\r\nDevelopment Environment\r\n-----------------------\r\n\r\nI developed the application on Ubuntu linux using Sublime Text 2 for my text editor. I used an application called virtualenv, which allows isolated python installations so package version dependencies do not collide at an OS level. This is recommended practice for any project of sufficient complexity. While writing the application, I rigorously tested the code using python's built-in test runner and used pylint to provide static analysis which made up for the lack on an IDE. For package management I used pip, which provides easy downloads of packages in PyPy, the python package database. For version control, I used git on github since I intended for the application to be open-source from the beginning.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nThis assumes you are running on ubuntu linux machine with python already installed. First we install our dependencies using the command-line.\r\n\r\n```shell\r\nsudo apt-get install git pip libav\r\n```\r\n\r\ngit will allow us to download the code from github. pip is a python package manager that'll let us easily install our third-party libraries and libav is the encoding tools used for the actual conversion.\r\n\r\nNext we prepare a directory to download the code to and clone the git repository.\r\n\r\n```shell\r\nmkdir git-repos\r\ncd git-repos/\r\ngit clone https://github.com/thethomaseffect/travers-media-tools.git\r\n```\r\n\r\nNow we install the required python libraries (the web framework is one of them!)\r\n\r\n```shell\r\npip install pexpect django\r\n```\r\n\r\nLastly, your own filepicker.io API key must be added to /encoder/settings.py. For now, I've left mine there so you shouldn't need to do anything, but I'll very likely remove it in the near future. If in doubt, check the git commit history.\r\n\r\n\r\nRunning\r\n-------\r\n\r\nNow we're ready to go! We'll build the database and run the test server! If you're prompted to create a superuser/admin type 'no' and hit return.\r\n\r\n```shell\r\ncd git-repos/travers-media-tools/encoder/\r\npython manage.py syncdb\r\npython manage.py runserver\r\n```\r\n\r\nif you're already running something on port 8000, just add a space and a new port number after runserver.\r\n\r\nIf everything was done right, the server should now be running and available on localhost:8000. Open your web browser, go to the address and upload a media file. I can only guarantee that the included input_small.mkv will work correctly, though many more should work. After hitting upload and waiting a while the page will refresh and you should be able download your new file. congrats!\r\n\r\n\r\nInteresting Code Snippets\r\n-------------------------\r\n\r\n### Calculating the percentage of encoding complete\r\n\r\n```python\r\n    def get_time_elapsed(self):\r\n        \"\"\"\r\n        Returns a int between 0 and 100 representing the percentage\r\n        of encoding currently completed.\r\n        \"\"\"\r\n        time_elapsed_regex = \".*?time=([+-]?\\\\d*\\\\.\\\\d+)(?![-+0-9\\\\.])\"\r\n        regex_group = re.compile(time_elapsed_regex, re.DOTALL)\r\n        if not self.alive():\r\n            return -1\r\n        subprocess_output = self.encoder_thread.subprocess_output\r\n        percentage_elapsed = lambda x: float(\r\n            (x / self.media_object.media_duration) * 100)\r\n        if subprocess_output:\r\n            regex_match = regex_group.search(subprocess_output[-1])\r\n            if regex_match:\r\n                # INFO: In Python 3.x round returns an int so the cast to float\r\n                # can safely be removed\r\n                current_percentage = percentage_elapsed(\r\n                    round(float(regex_match.group(1))))\r\n                return int(current_percentage)\r\n        return -1\r\n```\r\n\r\n```python\r\ndef get_media_duration(self):\r\n    \"\"\"\r\n    Spawns an avprobe process to get the media duration.\r\n\r\n    Spawns an avprobe process and saves the output to a list, then uses\r\n    regex to find the duration of the media and return it as an integer.\r\n    \"\"\"\r\n    subprocess_command = \"/usr/bin/avprobe \" + self.input_filename\r\n    info_process = pexpect.spawn(subprocess_command)\r\n    subprocess_output = info_process.readlines()\r\n    info_process.close\r\n\r\n    duration_regex = \".*?Duration: .*?(\\\\d+):(\\\\d+):(\\\\d+).(\\\\d+)\"\r\n    regex_group = re.compile(duration_regex, re.IGNORECASE | re.DOTALL)\r\n\r\n    def round_milliseconds(milliseconds):\r\n        return round(float(milliseconds) / 100)\r\n\r\n    for line in subprocess_output:\r\n        regex_match = regex_group.search(line)\r\n        if regex_match:\r\n            # Return the total duration in seconds\r\n            return ((int(regex_match.group(1)) * 3600) +\r\n                    (int(regex_match.group(2)) * 60) +\r\n                    int(regex_match.group(3)) +\r\n                    int(round_milliseconds(regex_match.group(4))))\r\n    # Not found so it's possible the process terminated early or an update\r\n    # broke the regex. Unlikely but we must return something just in case.\r\n    return -1\r\n```\r\n\r\nNote that this demonstrates Python's nested functions. round_milliseconds is only viable in the scope of the get_media_duration function. percentage_elapsed uses a lambda anonymous function which provides exactly the same functionality but is more suited to one-line expressions.\r\n\r\n### Encoder Thread\r\n\r\n```python\r\nclass EncodingThread(threading.Thread):\r\n\r\n    \"\"\"Do a thing\"\"\"\r\n\r\n    def __init__(self, media_object):\r\n        \"\"\"Does a thing\"\"\"\r\n        threading.Thread.__init__(self)\r\n        self.media_object = media_object\r\n        self.subprocess_output = []\r\n\r\n    def run(self):\r\n        \"\"\"Does a thing\"\"\"\r\n        # Some sensible defaults, such as overwriting if destination already\r\n        # exists\r\n        subprocess_command = \"/usr/bin/avconv -i \" + \\\r\n            self.media_object.input_filename + \" -y \" + \\\r\n            self.media_object.output_filename\r\n        encoding_process = pexpect.spawn(subprocess_command)\r\n        print (\"Started %s\" % subprocess_command)\r\n        compiled_regex_list = \\\r\n            encoding_process.compile_pattern_list([pexpect.EOF, '(.+)'])\r\n        while True:\r\n            i = encoding_process.expect_list(compiled_regex_list, timeout=None)\r\n            if i == 0:  # EOF\r\n                print (\"%s Process Finished\" % subprocess_command)\r\n                break\r\n            else:\r\n                output_line = encoding_process.match.group(0).rstrip()\r\n                # Check the index of the first occurrence of frame=\r\n                # Sadly this varies so we must also check 0\r\n                if output_line.find(\"frame=\") is 7 or 0:\r\n                    self.subprocess_output.append(output_line)\r\n        encoding_process.close\r\n```\r\n\r\nThis demonstrates how object-orientated python looks, and also the correct way thread classes should be written (ie. only one method - run()). Anywhere the self keyword can be found there's likely to be some OO at work. Interestingly, despite encouraging an imperative style, everything in python is an object. This can easily be shown with the following code in the python interpreter:\r\n\r\n```python\r\nnumber = 1\r\ndir(number)\r\n```\r\n\r\nThis will print all of number's methods, proving it is an object.\r\n\r\nThe above code also shows how pexpect works. There's plenty of regular expressions too for those who are fans!\r\n\r\n### Serving static files through Django\r\n\r\n```python\r\nMEDIA_DOWNLOADS_ROOT = os.path.join(os.getcwd(),'media/finished/')\r\n# ...\r\n# Serves files from domain/downloads/\r\n(r'^downloads/(?P<path>.*)$', 'django.views.static.serve',\r\n    {'document_root': MEDIA_DOWNLOADS_ROOT}),\r\n```\r\n\r\nFor production environments, something like apache would be more suited to this task but for testing it's very convenient!\r\n\r\n### Running POST requests on the server\r\n\r\n```python\r\ndef home(request):\r\n    message = None\r\n    if request.method == \"POST\":\r\n        print \"POST parameters: \", request.POST\r\n        print \"Files: \", request.FILES\r\n\r\n        # Build the form\r\n        form = models.UploadModelForm(request.POST, request.FILES)\r\n\r\n        if form.is_valid():\r\n            # Read the data and upload it to the location defined in UploadModel\r\n            form.save()\r\n\r\n            # Save the name of the uploaded file\r\n            uploaded_filename = form.cleaned_data['filepicker_file'].name\r\n\r\n            # Build the full input path to the file\r\n            MEDIA_UPLOAD_ROOT = os.path.join(os.getcwd(),'media/uploads/')\r\n            input_path = MEDIA_UPLOAD_ROOT + uploaded_filename\r\n\r\n            # Build the output filename\r\n            output_filename = uploaded_filename + \"_transcoded.mkv\"\r\n\r\n            # Build the output path\r\n            MEDIA_DOWNLOADS_ROOT = os.path.join(os.getcwd(),'media/finished/')\r\n            output_path = MEDIA_DOWNLOADS_ROOT + output_filename\r\n\r\n            # Transcode the file\r\n            video_encoder = Encoder(input_path, output_path)\r\n            video_encoder.start()\r\n            while video_encoder.alive():\r\n                print(video_encoder.get_time_elapsed())\r\n                time.sleep(0.1)\r\n\r\n            # Return the path to the file\r\n            message = output_filename\r\n        else:\r\n            message = None\r\n    else:\r\n        form = models.UploadModelForm()\r\n\r\n    return render(request, \"home.html\", {'form': form, 'message': message})\r\n```\r\n\r\nThis is the code that processes the request, encodes the video and returns the info needed to generate the download link. To demonstrate the percentage function works it prints to the console, but in a production version of the application an AJAX function on the client-side would request this instead to update a progress bar. As Javascript, JQuery, AJAX and CSS were outside the scope of my project I didn't implement this, but it could be done very quickly.\r\n\r\n### File Upload Database Model\r\n\r\n```python\r\nfrom django.db import models\r\nfrom django import forms\r\nimport django_filepicker\r\n\r\n\r\nclass UploadModel(models.Model):\r\n    # FPFileField renders as a filepicker dragdrop widget, but when accessed will\r\n    # provide a File-like interface.\r\n    filepicker_file = django_filepicker.models.FPFileField(upload_to='uploads')\r\n\r\nclass UploadModelForm(forms.ModelForm):\r\n    class Meta:\r\n        model = UploadModel\r\n```\r\n\r\nThis is the code that is used to automatically generate what's required in the database to allow the use of filepicker.io for uploads.\r\n\r\nFinal Thoughts\r\n--------------\r\n\r\nI really enjoyed doing this project and learned a lot. I'd like to continue working on it as an open-source project as there is a real gap in the market for a product like this. The only people offering a similar service are charging for it so it has potential to grow as a free open-source software project. I think if possible I would wrap a C++ API instead of console output and compile my own version of libav so that the application is less sensitive to regex-breaking updates.\r\n\r\nLearning a modern scripting language like python is very valuable and I've found it my go-to language whenever I want to quickly demonstrate some idea or algorithm. Thanks to implementations such as IronPython I've been able use it together with C# to enhance software such as games where scripting is highly valuable yet performance is critical.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}